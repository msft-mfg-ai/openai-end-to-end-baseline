# ------------------------------------------------------------------------------------------------------------------------
# Reusable Workflow: Deploy Azure Resources Only
# ------------------------------------------------------------------------------------------------------------------------
name: z_template_deploy_infra
run-name: Deploy Bicep
on:
  workflow_call:
    inputs:
      envCode:
        required: true
        type: string
      # Group template-related parameters into a single JSON input to reduce total inputs
      templateConfig:
        description: |
          JSON string with template configuration. Example:
          '{"templatePath":"infra/bicep/","templateFile":"main-advanced.bicep","parameterFile":"","parameterFileReplaceTokens":"false"}'
        required: false
        type: string
        default: '{"templatePath":"infra/bicep/","templateFile":"main-advanced.bicep","parameterFile":"","parameterFileReplaceTokens":"false"}'
      deploymentMode:
        required: false
        type: string
        default: 'Incremental'
      runCreateInfra:
        required: false
        default: true
        type: boolean
      deployInResourceGroup:
        required: false
        default: true
        type: boolean
      loginUsingClientSecret:
        description: Login using Client Secret?
        type: boolean
        default: false
      # Deployment stack action: 'deploy' (default), 'rollback', 'status'
      stackAction:
        description: "Deployment stack action (default: 'deploy'). Allowed values: 'deploy', 'rollback', 'status'"
        type: string
        default: 'deploy'
      requestorName:
        description: Requestor Name
        type: string
        default: '${{ github.actor }}'
      # instance:
      #   description: Instance number for resource naming
      #   type: string
      #   default: '001'

# ------------------------------------------------------------------------------------------------------------------------
jobs:
  deploy:
    name: Deploy Bicep
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.envCode }}
    permissions:
      id-token: write
      contents: read
      actions: read
      pages: write

    # ------------------------------------------------------------------------------------------------------------------------
    # Variables
    # ------------------------------------------------------------------------------------------------------------------------
    env:
      envCode: ${{ inputs.envCode }}
      # Parse templateConfig JSON for use in steps
      templatePath: ${{ fromJson(inputs.templateConfig).templatePath }}
      templateFile: ${{ fromJson(inputs.templateConfig).templateFile }}
      parameterFile: ${{ fromJson(inputs.templateConfig).parameterFile }}
      parameterFileReplaceTokens: ${{ fromJson(inputs.templateConfig).parameterFileReplaceTokens }}
      generatedResourceGroupName: ${{ vars.RESOURCEGROUP_PREFIX }}-${{ inputs.envCode }}-${{ vars.GLOBAL_REGION_CODE }}-${{ vars.INSTANCE_NUMBER }}
      loginWithFederatedIdentity: ${{ secrets.CICD_CLIENT_SECRET == '' && 'true' || 'false' }}
      loginWithSecret: ${{ secrets.CICD_CLIENT_SECRET != '' && 'true' || 'false' }}
      # Infrastructure Configuration (hardcoded to avoid 10-parameter limit)
      createResourceGroup: false
      publicAccessEnabled: false
      createDnsZones: false
      deployAIHub: false
      addRoleAssignments: true
      runBuildDeployAPI: false
      requestorName: ${{ github.actor }}
      # Deployment Stack Environment Variables (hardcoded - no input parameters to avoid 10-param limit)
      stackAction: ${{ inputs.stackAction }}  # Options: deploy (default), rollback, status
      stackName: ${{ format('stack-{0}-{1}-{2}', vars.APP_NAME, inputs.envCode, vars.INSTANCE_NUMBER) }}
      denySettingsMode: "none"  # Options: none, denyDelete, denyWriteAndDelete
      enableDriftDetection: "true"
      rollbackOnFailure: "true"
 
    # ------------------------------------------------------------------------------------------------------------------------
    # Outputs
    # ------------------------------------------------------------------------------------------------------------------------
    outputs:
      HUB_ID: ${{ steps.job-outputs.outputs.HUB_ID }}
      HUB_NAME: ${{ steps.job-outputs.outputs.HUB_NAME }}
  
    # ------------------------------------------------------------------------------------------------------------------------
    # Actions
    # ------------------------------------------------------------------------------------------------------------------------
    steps:
      - name: Checkout Code
        if: ${{ inputs.runCreateInfra }}
        uses: actions/checkout@v4

      - name: Get the current date
        id: get-date
        run: echo "DATE_TIME_STAMP=$(date +'%Y%m%d%H%M')" >> $GITHUB_OUTPUT

      - name: Display Variables and Files
        run: |-
          echo "inputs.envCode=${{ inputs.envCode }}"
          echo "env.generatedResourceGroupName=${{ env.generatedResourceGroupName }}"
          echo "templateFilePath=${{ env.templatePath }}${{ env.templateFile }}"
          echo "parameterFilePath=${{ env.templatePath }}${{ env.parameterFile }}"

          echo "vars.APP_NAME=${{ vars.APP_NAME }}"
          echo "vars.RESOURCEGROUP_PREFIX=${{ vars.RESOURCEGROUP_PREFIX }}"
          echo "vars.RESOURCEGROUP_LOCATION=${{ vars.RESOURCEGROUP_LOCATION }}"
          echo "vars.OPENAI_DEPLOY_LOCATION=${{ vars.OPENAI_DEPLOY_LOCATION }}"
          echo "vars.GLOBAL_REGION_CODE=${{ vars.GLOBAL_REGION_CODE }}"
          echo "vars.INSTANCE_NUMBER=${{ vars.INSTANCE_NUMBER }}"
          echo "vars.OWNER_EMAIL=${{ vars.OWNER_EMAIL || 'not-set' }}"

          echo "env.loginWithSecret=${{ env.loginWithSecret }}"
          echo "env.loginWithFederatedIdentity=${{ env.loginWithFederatedIdentity }}"
          echo "inputs.loginUsingClientSecret=${{ inputs.loginUsingClientSecret }}"

          echo "env.templatePath=${{ env.templatePath }}"
          echo "env.templateFile=${{ env.templateFile }}"
          echo "env.parameterFile=${{ env.parameterFile }}"
          echo "env.parameterFileReplaceTokens=${{ env.parameterFileReplaceTokens }}"
          echo "---------------------------------"
          echo "##[group]All Variables:"
          echo "Environment:"
          echo '${{ toJSON(env) }}'
          echo "Variables:"
          echo '${{ toJSON(vars) }}'
          echo "Secrets:"
          echo '${{ toJSON(secrets) }}'
          echo "Inputs:"
          echo '${{ toJSON(inputs) }}'
          echo "##[endgroup]"
          echo "---------------------------------"
          echo "##[group]Directory of ${{ github.workspace  }}"
          tree -R ${{ github.workspace  }}
          echo "##[endgroup]"        continue-on-error: true

      - name: Replace Tokens
        if: ${{ inputs.runCreateInfra && env.parameterFileReplaceTokens == 'true' }}
        run: |-
          parameterFile="${{ env.templatePath }}${{ env.parameterFile }}"
          
          echo "Replacing tokens in parameter file: $parameterFile"
          
          # Create a backup of the original file
          cp "$parameterFile" "${parameterFile}.backup"          # Replace tokens with their corresponding values
          sed -i "s|#{GLOBAL_REGION_CODE}#|${{ vars.GLOBAL_REGION_CODE }}|g" "$parameterFile"
          sed -i "s|#{RESOURCEGROUP_PREFIX}#|${{ vars.RESOURCEGROUP_PREFIX }}|g" "$parameterFile"
          sed -i "s|#{RESOURCEGROUP_LOCATION}#|${{ vars.RESOURCEGROUP_LOCATION }}|g" "$parameterFile"
          sed -i "s|#{OPENAI_DEPLOY_LOCATION}#|${{ vars.OPENAI_DEPLOY_LOCATION }}|g" "$parameterFile"
          sed -i "s|#{INSTANCE_NUMBER}#|${{ vars.INSTANCE_NUMBER }}|g" "$parameterFile"
          sed -i "s|#{APP_NAME}#|${{ vars.APP_NAME }}|g" "$parameterFile"
          sed -i "s|#{OWNER_EMAIL}#|${{ vars.OWNER_EMAIL }}|g" "$parameterFile"
          sed -i "s|#{envCode}#|${{ inputs.envCode }}|g" "$parameterFile"
          sed -i "s|#{envcode}#|${{ inputs.envCode }}|g" "$parameterFile"
          
          # Replace additional common tokens that may be found in parameters
          sed -i "s|#{APP_NAME_NO_DASHES}#|${{ vars.APP_NAME }}|g" "$parameterFile"
          
          echo "Token replacement completed. Updated parameter file:"
          cat "$parameterFile"

      - name: Display Param File
        run: |-
          echo "##[group]Contents of ${{ env.templatePath }}${{ env.parameterFile }}"
          cat ${{ env.templatePath }}${{ env.parameterFile }}
          echo "##[endgroup]"
        continue-on-error: true

      # https://learn.microsoft.com/en-us/entra/workload-id/workload-identity-federation-create-trust
      - name: OIDC Login to Azure
        if: ${{ !inputs.loginUsingClientSecret }}
        # if: $ { { env.loginWithFederatedIdentity } }
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.CICD_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to Azure with Secret
        if: ${{ inputs.loginUsingClientSecret }}
        # if: $ { { env.loginWithSecret } }  // this looks right but it ALWAYS runs then fails if secret is missing...
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.CICD_CLIENT_ID }}","clientSecret":"${{ secrets.CICD_CLIENT_SECRET }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}'

      - name: Create Resource Group
        if: ${{ inputs.runCreateInfra && inputs.deployInResourceGroup }}
        run: az group create --resource-group ${{ env.generatedResourceGroupName }} --location ${{ vars.RESOURCEGROUP_LOCATION }} --tags Environment=${{ inputs.envCode }}      # Deploy using Azure Stack (Subscription scope)
      - name: Deploy Azure Resources using Stack (Sub)
        if: ${{ inputs.runCreateInfra && !inputs.deployInResourceGroup }}
        id: deploy-stack-sub
        run: |
          deploymentName="${{ env.templateFile }}-sub-${{ vars.RESOURCEGROUP_LOCATION }}-${{ steps.get-date.outputs.DATE_TIME_STAMP}}"
          
          # Execute stack deployment based on the specified action
          if [[ "${{ inputs.stackAction }}" == "deploy" ]]; then
            echo "Running deployment stack action: create"
            az stack sub create \
              --name "$deploymentName" \
              --location ${{ vars.RESOURCEGROUP_LOCATION }} \
              --template-file ${{ env.templatePath }}${{ env.templateFile }} \
              --parameters ${{ env.templatePath }}${{ env.parameterFile }} \
              --deny-settings-mode none \
              --output json > stack_output_sub.json
            
            # Extract outputs from stack deployment result
            cat stack_output_sub.json
            # TODO: Add code to parse and set output variables if needed
          
          elif [[ "${{ inputs.stackAction }}" == "rollback" ]]; then
            echo "Running rollback stack action for previous deployment"
            az stack sub delete --name "$deploymentName" --location ${{ vars.RESOURCEGROUP_LOCATION }} --yes
          
          elif [[ "${{ inputs.stackAction }}" == "status" ]]; then
            echo "Getting deployment stack status"
            az stack sub show --name "$deploymentName" --location ${{ vars.RESOURCEGROUP_LOCATION }}
          
          else
            echo "Invalid stack action: ${{ inputs.stackAction }}"
            exit 1
          fi      # Deploy using Azure Stack (Resource Group scope)
      - name: Deploy Azure Resources using Stack (RG)
        if: ${{ inputs.runCreateInfra && inputs.deployInResourceGroup }}
        id: deploy-stack-rg
        run: |
          deploymentName="${{ env.templateFile }}-rg-${{ vars.RESOURCEGROUP_LOCATION }}-${{ steps.get-date.outputs.DATE_TIME_STAMP}}"
          
          # Execute stack deployment based on the specified action
          if [[ "${{ inputs.stackAction }}" == "deploy" ]]; then
            echo "Running deployment stack action: create"
            az stack group create \
              --name "$deploymentName" \
              --resource-group ${{ env.generatedResourceGroupName }} \
              --template-file ${{ env.templatePath }}${{ env.templateFile }} \
              --parameters ${{ env.templatePath }}${{ env.parameterFile }} \
              --deny-settings-mode none \
              --action-on-unmanage deleteResources \
              --output json > stack_output_rg.json
            
            # Extract outputs from stack deployment result for use in later steps
            cat stack_output_rg.json
            
            # Extract all output values for use in later steps
            ACR_NAME=$(jq -r '.properties.outputs.ACR_NAME.value // "null"' stack_output_rg.json)
            ACR_URL=$(jq -r '.properties.outputs.ACR_URL.value // "null"' stack_output_rg.json)
            AI_ENDPOINT=$(jq -r '.properties.outputs.AI_ENDPOINT.value // "null"' stack_output_rg.json)
            AI_HUB_ID=$(jq -r '.properties.outputs.AI_HUB_ID.value // "null"' stack_output_rg.json)
            AI_HUB_NAME=$(jq -r '.properties.outputs.AI_HUB_NAME.value // "null"' stack_output_rg.json)
            AI_SEARCH_ENDPOINT=$(jq -r '.properties.outputs.AI_SEARCH_ENDPOINT.value // "null"' stack_output_rg.json)
            UI_CONTAINER_APP_FQDN=$(jq -r '.properties.outputs.UI_CONTAINER_APP_FQDN.value // "null"' stack_output_rg.json)
            UI_CONTAINER_APP_NAME=$(jq -r '.properties.outputs.UI_CONTAINER_APP_NAME.value // "null"' stack_output_rg.json)
            API_KEY=$(jq -r '.properties.outputs.API_KEY.value // "null"' stack_output_rg.json)
            AZURE_CONTAINER_ENVIRONMENT_NAME=$(jq -r '.properties.outputs.AZURE_CONTAINER_ENVIRONMENT_NAME.value // "null"' stack_output_rg.json)
            AZURE_CONTAINER_REGISTRY_ENDPOINT=$(jq -r '.properties.outputs.AZURE_CONTAINER_REGISTRY_ENDPOINT.value // "null"' stack_output_rg.json)
            AZURE_CONTAINER_REGISTRY_NAME=$(jq -r '.properties.outputs.AZURE_CONTAINER_REGISTRY_NAME.value // "null"' stack_output_rg.json)
            AZURE_RESOURCE_GROUP=$(jq -r '.properties.outputs.AZURE_RESOURCE_GROUP.value // "null"' stack_output_rg.json)
            COSMOS_CONTAINER_NAME=$(jq -r '.properties.outputs.COSMOS_CONTAINER_NAME.value // "null"' stack_output_rg.json)
            COSMOS_DATABASE_NAME=$(jq -r '.properties.outputs.COSMOS_DATABASE_NAME.value // "null"' stack_output_rg.json)
            COSMOS_ENDPOINT=$(jq -r '.properties.outputs.COSMOS_ENDPOINT.value // "null"' stack_output_rg.json)
            DOCUMENT_INTELLIGENCE_ENDPOINT=$(jq -r '.properties.outputs.DOCUMENT_INTELLIGENCE_ENDPOINT.value // "null"' stack_output_rg.json)
            MANAGED_ENVIRONMENT_ID=$(jq -r '.properties.outputs.MANAGED_ENVIRONMENT_ID.value // "null"' stack_output_rg.json)
            MANAGED_ENVIRONMENT_NAME=$(jq -r '.properties.outputs.MANAGED_ENVIRONMENT_NAME.value // "null"' stack_output_rg.json)
            RESOURCE_TOKEN=$(jq -r '.properties.outputs.RESOURCE_TOKEN.value // "null"' stack_output_rg.json)
            STORAGE_ACCOUNT_CONTAINER=$(jq -r '.properties.outputs.STORAGE_ACCOUNT_CONTAINER.value // "null"' stack_output_rg.json)
            STORAGE_ACCOUNT_NAME=$(jq -r '.properties.outputs.STORAGE_ACCOUNT_NAME.value // "null"' stack_output_rg.json)
            VNET_CORE_ID=$(jq -r '.properties.outputs.VNET_CORE_ID.value // "null"' stack_output_rg.json)
            VNET_CORE_NAME=$(jq -r '.properties.outputs.VNET_CORE_NAME.value // "null"' stack_output_rg.json)
            VNET_CORE_PREFIX=$(jq -r '.properties.outputs.VNET_CORE_PREFIX.value // "null"' stack_output_rg.json)
            
            # Set outputs as environment variables
            echo "ACR_NAME=${ACR_NAME}" >> $GITHUB_ENV
            echo "ACR_URL=${ACR_URL}" >> $GITHUB_ENV
            echo "AI_ENDPOINT=${AI_ENDPOINT}" >> $GITHUB_ENV
            echo "AI_HUB_ID=${AI_HUB_ID}" >> $GITHUB_ENV
            echo "AI_HUB_NAME=${AI_HUB_NAME}" >> $GITHUB_ENV
            echo "AI_SEARCH_ENDPOINT=${AI_SEARCH_ENDPOINT}" >> $GITHUB_ENV
            echo "UI_CONTAINER_APP_FQDN=${UI_CONTAINER_APP_FQDN}" >> $GITHUB_ENV
            echo "UI_CONTAINER_APP_NAME=${UI_CONTAINER_APP_NAME}" >> $GITHUB_ENV
            echo "API_KEY=${API_KEY}" >> $GITHUB_ENV
            echo "AZURE_CONTAINER_ENVIRONMENT_NAME=${AZURE_CONTAINER_ENVIRONMENT_NAME}" >> $GITHUB_ENV
            echo "AZURE_CONTAINER_REGISTRY_ENDPOINT=${AZURE_CONTAINER_REGISTRY_ENDPOINT}" >> $GITHUB_ENV
            echo "AZURE_CONTAINER_REGISTRY_NAME=${AZURE_CONTAINER_REGISTRY_NAME}" >> $GITHUB_ENV
            echo "AZURE_RESOURCE_GROUP=${AZURE_RESOURCE_GROUP}" >> $GITHUB_ENV
            echo "COSMOS_CONTAINER_NAME=${COSMOS_CONTAINER_NAME}" >> $GITHUB_ENV
            echo "COSMOS_DATABASE_NAME=${COSMOS_DATABASE_NAME}" >> $GITHUB_ENV
            echo "COSMOS_ENDPOINT=${COSMOS_ENDPOINT}" >> $GITHUB_ENV
            echo "DOCUMENT_INTELLIGENCE_ENDPOINT=${DOCUMENT_INTELLIGENCE_ENDPOINT}" >> $GITHUB_ENV
            echo "MANAGED_ENVIRONMENT_ID=${MANAGED_ENVIRONMENT_ID}" >> $GITHUB_ENV
            echo "MANAGED_ENVIRONMENT_NAME=${MANAGED_ENVIRONMENT_NAME}" >> $GITHUB_ENV
            echo "RESOURCE_TOKEN=${RESOURCE_TOKEN}" >> $GITHUB_ENV
            echo "STORAGE_ACCOUNT_CONTAINER=${STORAGE_ACCOUNT_CONTAINER}" >> $GITHUB_ENV
            echo "STORAGE_ACCOUNT_NAME=${STORAGE_ACCOUNT_NAME}" >> $GITHUB_ENV
            echo "VNET_CORE_ID=${VNET_CORE_ID}" >> $GITHUB_ENV
            echo "VNET_CORE_NAME=${VNET_CORE_NAME}" >> $GITHUB_ENV
            echo "VNET_CORE_PREFIX=${VNET_CORE_PREFIX}" >> $GITHUB_ENV
            elif [[ "${{ inputs.stackAction }}" == "rollback" ]]; then
            echo "Running rollback stack action for previous deployment"
            az stack group delete --name "$deploymentName" --resource-group ${{ env.generatedResourceGroupName }} --yes
          
          elif [[ "${{ inputs.stackAction }}" == "status" ]]; then
            echo "Getting deployment stack status"
            az stack group show --name "$deploymentName" --resource-group ${{ env.generatedResourceGroupName }}
          
          else
            echo "Invalid stack action: ${{ inputs.stackAction }}"
            exit 1
          fi

      - name: Display Output
        if: ${{ inputs.runCreateInfra && inputs.stackAction == 'deploy' }}
        run: |-
          echo "ACR_NAME=${ACR_NAME}"
          echo "ACR_URL=${ACR_URL}"
          echo "AI_ENDPOINT=${AI_ENDPOINT}"
          echo "AI_HUB_ID=${AI_HUB_ID}"
          echo "AI_HUB_NAME=${AI_HUB_NAME}"
          echo "AI_SEARCH_ENDPOINT=${AI_SEARCH_ENDPOINT}"
          echo "UI_CONTAINER_APP_FQDN=${UI_CONTAINER_APP_FQDN}"
          echo "UI_CONTAINER_APP_NAME=${UI_CONTAINER_APP_NAME}"
          echo "API_KEY=${API_KEY}"
          echo "AZURE_CONTAINER_ENVIRONMENT_NAME=${AZURE_CONTAINER_ENVIRONMENT_NAME}"
          echo "AZURE_CONTAINER_REGISTRY_ENDPOINT=${AZURE_CONTAINER_REGISTRY_ENDPOINT}"
          echo "AZURE_CONTAINER_REGISTRY_NAME=${AZURE_CONTAINER_REGISTRY_NAME}"
          echo "AZURE_RESOURCE_GROUP=${AZURE_RESOURCE_GROUP}"
          echo "COSMOS_CONTAINER_NAME=${COSMOS_CONTAINER_NAME}"
          echo "COSMOS_DATABASE_NAME=${COSMOS_DATABASE_NAME}"
          echo "COSMOS_ENDPOINT=${COSMOS_ENDPOINT}"
          echo "DOCUMENT_INTELLIGENCE_ENDPOINT=${DOCUMENT_INTELLIGENCE_ENDPOINT}"
          echo "MANAGED_ENVIRONMENT_ID=${MANAGED_ENVIRONMENT_ID}"
          echo "MANAGED_ENVIRONMENT_NAME=${MANAGED_ENVIRONMENT_NAME}"
          echo "RESOURCE_TOKEN=${RESOURCE_TOKEN}"
          echo "STORAGE_ACCOUNT_CONTAINER=${STORAGE_ACCOUNT_CONTAINER}"
          echo "STORAGE_ACCOUNT_NAME=${STORAGE_ACCOUNT_NAME}"
          echo "VNET_CORE_ID=${VNET_CORE_ID}"
          echo "VNET_CORE_NAME=${VNET_CORE_NAME}"
          echo "VNET_CORE_PREFIX=${VNET_CORE_PREFIX}"
        continue-on-error: true

      - name: Set job outputs
        if: ${{ inputs.runCreateInfra && inputs.stackAction == 'deploy' }}
        run: |
          # Set outputs for job outputs using GITHUB_OUTPUT
          echo "HUB_ID=${AI_HUB_ID}" >> $GITHUB_OUTPUT
          echo "HUB_NAME=${AI_HUB_NAME}" >> $GITHUB_OUTPUT
        id: job-outputs

      - name: Write summary
        if: ${{ inputs.runCreateInfra }}
        run: |
          # Create summary with available information
          SUMMARY="# Deployment summary"
          SUMMARY="${SUMMARY}\n- Resource Group: ${generatedResourceGroupName}"
          
          # Add AI Hub Name if available
          if [[ -n "${AI_HUB_NAME}" && "${AI_HUB_NAME}" != "null" ]]; then
            SUMMARY="${SUMMARY}\n- AI Hub Name: ${AI_HUB_NAME}"
          fi
          
          # Add API URL if available
          if [[ -n "${UI_CONTAINER_APP_FQDN}" && "${UI_CONTAINER_APP_FQDN}" != "null" ]]; then
            SUMMARY="${SUMMARY}\n- API URL: [${UI_CONTAINER_APP_FQDN}](${UI_CONTAINER_APP_FQDN})"
          fi
          
          echo -e "${SUMMARY}" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true
        # - Link to App URL: [https://${{ env.hostName }}](https://${{ env.hostName }})

      - name: Parse Template Configuration
        id: parse-template-config
        run: |
          # Parse templateConfig JSON input
          templatePath=$(echo '${{ inputs.templateConfig }}' | jq -r '.templatePath')
          templateFile=$(echo '${{ inputs.templateConfig }}' | jq -r '.templateFile')
          parameterFile=$(echo '${{ inputs.templateConfig }}' | jq -r '.parameterFile')
          parameterFileReplaceTokens=$(echo '${{ inputs.templateConfig }}' | jq -r '.parameterFileReplaceTokens')
          
          echo "templatePath=${templatePath}" >> $GITHUB_ENV
          echo "templateFile=${templateFile}" >> $GITHUB_ENV
          echo "parameterFile=${parameterFile}" >> $GITHUB_ENV
          echo "parameterFileReplaceTokens=${parameterFileReplaceTokens}" >> $GITHUB_ENV
